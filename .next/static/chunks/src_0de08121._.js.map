{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/hooks/use-toast.ts"],"sourcesContent":["\"use client\"\n\n// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS;IAAG,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,SAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,OAAH,QAAA,SAAA,CAAA,KAAuB;;IACxC,OAAO,IAAA,yKAAO,EAAC,IAAA,gJAAI,EAAC;AACtB","debugId":null}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/components/ui/toast.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AAPA;;;;;;;AASA,MAAM,gBAAgB,gLAAwB;AAE9C,MAAM,8BAAgB,2KAAgB,MAGpC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,gLAAwB;QACvB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,qIACA;QAED,GAAG,KAAK;;;;;;;;AAGb,cAAc,WAAW,GAAG,gLAAwB,CAAC,WAAW;AAEhE,MAAM,gBAAgB,IAAA,0KAAG,EACvB,6lBACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,MAAM,sBAAQ,2KAAgB,OAI5B,QAAmC;QAAlC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO;IACjC,qBACE,6LAAC,4KAAoB;QACnB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;AAGf;;AACA,MAAM,WAAW,GAAG,4KAAoB,CAAC,WAAW;AAEpD,MAAM,4BAAc,2KAAgB,OAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,8KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,sgBACA;QAED,GAAG,KAAK;;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAsB,CAAC,WAAW;AAE5D,MAAM,2BAAa,2KAAgB,OAGjC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,6KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,yVACA;QAEF,eAAY;QACX,GAAG,KAAK;kBAET,cAAA,6LAAC,oMAAC;YAAC,WAAU;;;;;;;;;;;;;AAGjB,WAAW,WAAW,GAAG,6KAAqB,CAAC,WAAW;AAE1D,MAAM,2BAAa,2KAAgB,OAGjC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,6KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;;;AAGb,WAAW,WAAW,GAAG,6KAAqB,CAAC,WAAW;AAE1D,MAAM,iCAAmB,2KAAgB,QAGvC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,mLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,sBAAsB;QACnC,GAAG,KAAK;;;;;;;;AAGb,iBAAiB,WAAW,GAAG,mLAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/components/ui/toaster.tsx"],"sourcesContent":["\"use client\"\n\nimport { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;AAHA;;;AAYO,SAAS;;IACd,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,2IAAQ;IAE3B,qBACE,6LAAC,qJAAa;;YACX,OAAO,GAAG,CAAC,SAAU,KAA4C;oBAA5C,EAAE,EAAE,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,EAAE,GAAG,OAAO,GAA5C;gBACpB,qBACE,6LAAC,6IAAK;oBAAW,GAAG,KAAK;;sCACvB,6LAAC;4BAAI,WAAU;;gCACZ,uBAAS,6LAAC,kJAAU;8CAAE;;;;;;gCACtB,6BACC,6LAAC,wJAAgB;8CAAE;;;;;;;;;;;;wBAGtB;sCACD,6LAAC,kJAAU;;;;;;mBARD;;;;;YAWhB;0BACA,6LAAC,qJAAa;;;;;;;;;;;AAGpB;GAtBgB;;QACK,2IAAQ;;;KADb","debugId":null}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/config.ts"],"sourcesContent":["export const firebaseConfig = {\n  // These values are loaded from your .env file.\n  // Make sure you have them set there.\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY || \"\",\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || \"\",\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || \"\",\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET || \"\",\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID || \"\",\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID || \"\",\n  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID || \"\"\n};\n"],"names":[],"mappings":";;;;AAGU;AAHH,MAAM,iBAAiB;IAC5B,+CAA+C;IAC/C,qCAAqC;IACrC,QAAQ,gFAA4C;IACpD,YAAY,gEAAgD;IAC5D,WAAW,gDAA+C;IAC1D,eAAe,qEAAmD;IAClE,mBAAmB,oDAAwD;IAC3E,OAAO,kFAA2C;IAClD,eAAe,0EAAmD;AACpE","debugId":null}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/error-emitter.ts"],"sourcesContent":["'use client';\nimport { FirestorePermissionError } from '@/firebase/errors';\n\n/**\n * Defines the shape of all possible events and their corresponding payload types.\n * This centralizes event definitions for type safety across the application.\n */\nexport interface AppEvents {\n  'permission-error': FirestorePermissionError;\n}\n\n// A generic type for a callback function.\ntype Callback<T> = (data: T) => void;\n\n/**\n * A strongly-typed pub/sub event emitter.\n * It uses a generic type T that extends a record of event names to payload types.\n */\nfunction createEventEmitter<T extends Record<string, any>>() {\n  // The events object stores arrays of callbacks, keyed by event name.\n  // The types ensure that a callback for a specific event matches its payload type.\n  const events: { [K in keyof T]?: Array<Callback<T[K]>> } = {};\n\n  return {\n    /**\n     * Subscribe to an event.\n     * @param eventName The name of the event to subscribe to.\n     * @param callback The function to call when the event is emitted.\n     */\n    on<K extends keyof T>(eventName: K, callback: Callback<T[K]>) {\n      if (!events[eventName]) {\n        events[eventName] = [];\n      }\n      events[eventName]?.push(callback);\n    },\n\n    /**\n     * Unsubscribe from an event.\n     * @param eventName The name of the event to unsubscribe from.\n     * @param callback The specific callback to remove.\n     */\n    off<K extends keyof T>(eventName: K, callback: Callback<T[K]>) {\n      if (!events[eventName]) {\n        return;\n      }\n      events[eventName] = events[eventName]?.filter(cb => cb !== callback);\n    },\n\n    /**\n     * Publish an event to all subscribers.\n     * @param eventName The name of the event to emit.\n     * @param data The data payload that corresponds to the event's type.\n     */\n    emit<K extends keyof T>(eventName: K, data: T[K]) {\n      if (!events[eventName]) {\n        return;\n      }\n      events[eventName]?.forEach(callback => callback(data));\n    },\n  };\n}\n\n// Create and export a singleton instance of the emitter, typed with our AppEvents interface.\nexport const errorEmitter = createEventEmitter<AppEvents>();\n"],"names":[],"mappings":";;;;AAAA;AAcA;;;CAGC,GACD,SAAS;IACP,qEAAqE;IACrE,kFAAkF;IAClF,MAAM,SAAqD,CAAC;IAE5D,OAAO;QACL;;;;KAIC,GACD,IAAsB,SAAY,EAAE,QAAwB;gBAI1D;YAHA,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;gBACtB,MAAM,CAAC,UAAU,GAAG,EAAE;YACxB;aACA,oBAAA,MAAM,CAAC,UAAU,cAAjB,wCAAA,kBAAmB,IAAI,CAAC;QAC1B;QAEA;;;;KAIC,GACD,KAAuB,SAAY,EAAE,QAAwB;gBAIvC;YAHpB,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;gBACtB;YACF;YACA,MAAM,CAAC,UAAU,IAAG,oBAAA,MAAM,CAAC,UAAU,cAAjB,wCAAA,kBAAmB,MAAM,CAAC,CAAA,KAAM,OAAO;QAC7D;QAEA;;;;KAIC,GACD,MAAwB,SAAY,EAAE,IAAU;gBAI9C;YAHA,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;gBACtB;YACF;aACA,oBAAA,MAAM,CAAC,UAAU,cAAjB,wCAAA,kBAAmB,OAAO,CAAC,CAAA,WAAY,SAAS;QAClD;IACF;AACF;AAGO,MAAM,eAAe","debugId":null}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/components/FirebaseErrorListener.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport { errorEmitter } from '@/firebase/error-emitter';\nimport { FirestorePermissionError } from '@/firebase/errors';\n\n/**\n * An invisible component that listens for globally emitted 'permission-error' events.\n * It throws any received error to be caught by Next.js's global-error.tsx.\n */\nexport function FirebaseErrorListener() {\n  // Use the specific error type for the state for type safety.\n  const [error, setError] = useState<FirestorePermissionError | null>(null);\n\n  useEffect(() => {\n    // The callback now expects a strongly-typed error, matching the event payload.\n    const handleError = (error: FirestorePermissionError) => {\n      // Set error in state to trigger a re-render.\n      setError(error);\n    };\n\n    // The typed emitter will enforce that the callback for 'permission-error'\n    // matches the expected payload type (FirestorePermissionError).\n    errorEmitter.on('permission-error', handleError);\n\n    // Unsubscribe on unmount to prevent memory leaks.\n    return () => {\n      errorEmitter.off('permission-error', handleError);\n    };\n  }, []);\n\n  // On re-render, if an error exists in state, throw it.\n  if (error) {\n    throw error;\n  }\n\n  // This component renders nothing.\n  return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;;AAHA;;;AAUO,SAAS;;IACd,6DAA6D;IAC7D,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAkC;IAEpE,IAAA,0KAAS;2CAAC;YACR,+EAA+E;YAC/E,MAAM;+DAAc,CAAC;oBACnB,6CAA6C;oBAC7C,SAAS;gBACX;;YAEA,0EAA0E;YAC1E,gEAAgE;YAChE,sJAAY,CAAC,EAAE,CAAC,oBAAoB;YAEpC,kDAAkD;YAClD;mDAAO;oBACL,sJAAY,CAAC,GAAG,CAAC,oBAAoB;gBACvC;;QACF;0CAAG,EAAE;IAEL,uDAAuD;IACvD,IAAI,OAAO;QACT,MAAM;IACR;IAEA,kCAAkC;IAClC,OAAO;AACT;GA5BgB;KAAA","debugId":null}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/provider.tsx"],"sourcesContent":["'use client';\n\nimport React, { DependencyList, createContext, useContext, ReactNode, useMemo, useState, useEffect } from 'react';\nimport { FirebaseApp } from 'firebase/app';\nimport { Firestore } from 'firebase/firestore';\nimport { Auth, User, onAuthStateChanged } from 'firebase/auth';\nimport { FirebaseErrorListener } from '@/components/FirebaseErrorListener';\nimport type { Storage } from 'firebase/storage';\n\ninterface FirebaseProviderProps {\n  children: ReactNode;\n  firebaseApp: FirebaseApp | null;\n  firestore: Firestore | null;\n  auth: Auth | null;\n  storage: Storage | null;\n}\n\n// Internal state for user authentication\ninterface UserAuthState {\n  user: User | null;\n  isUserLoading: boolean;\n  userError: Error | null;\n}\n\n// Combined state for the Firebase context\nexport interface FirebaseContextState {\n  areServicesAvailable: boolean; // True if core services (app, firestore, auth instance) are provided\n  firebaseApp: FirebaseApp | null;\n  firestore: Firestore | null;\n  auth: Auth | null; // The Auth service instance\n  storage: Storage | null;\n  // User authentication state\n  user: User | null;\n  isUserLoading: boolean; // True during initial auth check\n  userError: Error | null; // Error from auth listener\n}\n\n// Return type for useFirebase()\nexport interface FirebaseServicesAndUser {\n  firebaseApp: FirebaseApp;\n  firestore: Firestore;\n  auth: Auth;\n  storage: Storage;\n  user: User | null;\n  isUserLoading: boolean;\n  userError: Error | null;\n}\n\n// Return type for useUser() - specific to user auth state\nexport interface UserHookResult { // Renamed from UserAuthHookResult for consistency if desired, or keep as UserAuthHookResult\n  user: User | null;\n  isUserLoading: boolean;\n  userError: Error | null;\n}\n\n// React Context\nexport const FirebaseContext = createContext<FirebaseContextState | undefined>(undefined);\n\n/**\n * FirebaseProvider manages and provides Firebase services and user authentication state.\n */\nexport const FirebaseProvider: React.FC<FirebaseProviderProps> = ({\n  children,\n  firebaseApp,\n  firestore,\n  auth,\n  storage,\n}) => {\n  const [userAuthState, setUserAuthState] = useState<UserAuthState>({\n    user: null,\n    isUserLoading: true, // Start loading until first auth event\n    userError: null,\n  });\n\n  // Effect to subscribe to Firebase auth state changes\n  useEffect(() => {\n    if (!auth) { // If no Auth service instance, cannot determine user state\n      setUserAuthState({ user: null, isUserLoading: false, userError: new Error(\"Auth service not provided.\") });\n      return;\n    }\n\n    setUserAuthState({ user: null, isUserLoading: true, userError: null }); // Reset on auth instance change\n\n    const unsubscribe = onAuthStateChanged(\n      auth,\n      (firebaseUser) => { // Auth state determined\n        setUserAuthState({ user: firebaseUser, isUserLoading: false, userError: null });\n      },\n      (error) => { // Auth listener error\n        console.error(\"FirebaseProvider: onAuthStateChanged error:\", error);\n        setUserAuthState({ user: null, isUserLoading: false, userError: error });\n      }\n    );\n    return () => unsubscribe(); // Cleanup\n  }, [auth]); // Depends on the auth instance\n\n  // Memoize the context value\n  const contextValue = useMemo((): FirebaseContextState => {\n    const servicesAvailable = !!(firebaseApp && firestore && auth && storage);\n    return {\n      areServicesAvailable: servicesAvailable,\n      firebaseApp: servicesAvailable ? firebaseApp : null,\n      firestore: servicesAvailable ? firestore : null,\n      auth: servicesAvailable ? auth : null,\n      storage: servicesAvailable ? storage : null,\n      user: userAuthState.user,\n      isUserLoading: userAuthState.isUserLoading,\n      userError: userAuthState.userError,\n    };\n  }, [firebaseApp, firestore, auth, storage, userAuthState]);\n\n  if (!contextValue.areServicesAvailable) {\n    return (\n        <div style={{ padding: '2rem', margin: '2rem', backgroundColor: '#fff5f5', color: '#c53030', border: '1px solid #fc8181', borderRadius: '0.5rem', fontFamily: 'sans-serif' }}>\n            <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1rem' }}>Error de Configuración de Firebase</h2>\n            <p style={{ marginBottom: '1rem' }}>No se pudo inicializar Firebase. Esto suele ocurrir por una de estas dos razones:</p>\n            <ol style={{ paddingLeft: '2rem', listStyleType: 'decimal' }}>\n                <li style={{ marginBottom: '0.75rem' }}>\n                    <strong>Faltan las claves de Firebase:</strong> Asegúrate de que tu archivo <code>.env</code> en la raíz del proyecto contiene todas las claves de configuración de Firebase (<code>NEXT_PUBLIC_FIREBASE_API_KEY</code>, etc.).\n                </li>\n                <li style={{ marginBottom: '0.75rem' }}>\n                    <strong>Claves incorrectas:</strong> La <code>NEXT_PUBLIC_FIREBASE_API_KEY</code> que has introducido no es válida o está mal escrita.\n                </li>\n            </ol>\n            <p>Por favor, revisa tu archivo <code>.env</code> y la configuración de tu proyecto en la <a href=\"https://console.firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\" style={{ color: '#2b6cb0', textDecoration: 'underline' }}>Consola de Firebase</a> para asegurarte de que las claves son correctas, y luego <strong>reinicia el servidor de desarrollo</strong>.</p>\n        </div>\n    )\n  }\n\n  return (\n    <FirebaseContext.Provider value={contextValue}>\n      <FirebaseErrorListener />\n      {children}\n    </FirebaseContext.Provider>\n  );\n};\n\n/**\n * Hook to access core Firebase services and user authentication state.\n * Throws error if core services are not available or used outside provider.\n */\nexport const useFirebase = (): FirebaseServicesAndUser => {\n  const context = useContext(FirebaseContext);\n\n  if (context === undefined) {\n    throw new Error('useFirebase must be used within a FirebaseProvider.');\n  }\n\n  if (!context.areServicesAvailable || !context.firebaseApp || !context.firestore || !context.auth || !context.storage) {\n    throw new Error('Firebase core services not available. Check FirebaseProvider props.');\n  }\n\n  return {\n    firebaseApp: context.firebaseApp,\n    firestore: context.firestore,\n    auth: context.auth,\n    storage: context.storage,\n    user: context.user,\n    isUserLoading: context.isUserLoading,\n    userError: context.userError,\n  };\n};\n\n/** Hook to access Firebase Auth instance. */\nexport const useAuth = (): Auth => {\n  const { auth } = useFirebase();\n  return auth;\n};\n\n/** Hook to access Firestore instance. */\nexport const useFirestore = (): Firestore => {\n  const { firestore } = useFirebase();\n  return firestore;\n};\n\n/** Hook to access Firebase App instance. */\nexport const useFirebaseApp = (): FirebaseApp => {\n  const { firebaseApp } = useFirebase();\n  return firebaseApp;\n};\n\n/** Hook to access Storage instance. */\nexport const useStorage = (): Storage => {\n  const { storage } = useFirebase();\n  return storage;\n};\n\ntype MemoFirebase <T> = T & {__memo?: boolean};\n\nexport function useMemoFirebase<T>(factory: () => T, deps: DependencyList): T | (MemoFirebase<T>) {\n  const memoized = useMemo(factory, deps);\n  \n  if(typeof memoized !== 'object' || memoized === null) return memoized;\n  (memoized as MemoFirebase<T>).__memo = true;\n  \n  return memoized;\n}\n\n/**\n * Hook specifically for accessing the authenticated user's state.\n * This provides the User object, loading status, and any auth errors.\n * @returns {UserHookResult} Object with user, isUserLoading, userError.\n */\nexport const useUser = (): UserHookResult => { // Renamed from useAuthUser\n  const { user, isUserLoading, userError } = useFirebase(); // Leverages the main hook\n  return { user, isUserLoading, userError };\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/client-provider.tsx"],"sourcesContent":["'use client';\n\nimport React, { useMemo, type ReactNode } from 'react';\nimport { FirebaseProvider } from '@/firebase/provider';\nimport { initializeFirebase } from '@/firebase';\n\ninterface FirebaseClientProviderProps {\n  children: ReactNode;\n}\n\nexport function FirebaseClientProvider({ children }: FirebaseClientProviderProps) {\n  const firebaseServices = useMemo(() => {\n    // Initialize Firebase on the client side, once per component mount.\n    try {\n      return initializeFirebase();\n    } catch (e) {\n      console.error(\"FATAL: Could not initialize Firebase. Please check your environment variables.\", e);\n      return { firebaseApp: null, auth: null, firestore: null, storage: null };\n    }\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  return (\n    <FirebaseProvider\n      firebaseApp={firebaseServices.firebaseApp}\n      auth={firebaseServices.auth}\n      firestore={firebaseServices.firestore}\n      storage={firebaseServices.storage}\n    >\n      {children}\n    </FirebaseProvider>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;;;AAJA;;;;AAUO,SAAS,uBAAuB,KAAyC;QAAzC,EAAE,QAAQ,EAA+B,GAAzC;;IACrC,MAAM,mBAAmB,IAAA,wKAAO;4DAAC;YAC/B,oEAAoE;YACpE,IAAI;gBACF,OAAO,IAAA,iKAAkB;YAC3B,EAAE,OAAO,GAAG;gBACV,QAAQ,KAAK,CAAC,kFAAkF;gBAChG,OAAO;oBAAE,aAAa;oBAAM,MAAM;oBAAM,WAAW;oBAAM,SAAS;gBAAK;YACzE;QACF;2DAAG,EAAE,GAAG,8DAA8D;IAEtE,qBACE,6LAAC,mJAAgB;QACf,aAAa,iBAAiB,WAAW;QACzC,MAAM,iBAAiB,IAAI;QAC3B,WAAW,iBAAiB,SAAS;QACrC,SAAS,iBAAiB,OAAO;kBAEhC;;;;;;AAGP;GArBgB;KAAA","debugId":null}},
    {"offset": {"line": 988, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/errors.ts"],"sourcesContent":["'use client';\nimport { getAuth, type User } from 'firebase/auth';\n\ntype SecurityRuleContext = {\n  path: string;\n  operation: 'get' | 'list' | 'create' | 'update' | 'delete' | 'write';\n  requestResourceData?: any;\n};\n\ninterface FirebaseAuthToken {\n  name: string | null;\n  email: string | null;\n  email_verified: boolean;\n  phone_number: string | null;\n  sub: string;\n  firebase: {\n    identities: Record<string, string[]>;\n    sign_in_provider: string;\n    tenant: string | null;\n  };\n}\n\ninterface FirebaseAuthObject {\n  uid: string;\n  token: FirebaseAuthToken;\n}\n\ninterface SecurityRuleRequest {\n  auth: FirebaseAuthObject | null;\n  method: string;\n  path: string;\n  resource?: {\n    data: any;\n  };\n}\n\n/**\n * Builds a security-rule-compliant auth object from the Firebase User.\n * @param currentUser The currently authenticated Firebase user.\n * @returns An object that mirrors request.auth in security rules, or null.\n */\nfunction buildAuthObject(currentUser: User | null): FirebaseAuthObject | null {\n  if (!currentUser) {\n    return null;\n  }\n\n  const token: FirebaseAuthToken = {\n    name: currentUser.displayName,\n    email: currentUser.email,\n    email_verified: currentUser.emailVerified,\n    phone_number: currentUser.phoneNumber,\n    sub: currentUser.uid,\n    firebase: {\n      identities: currentUser.providerData.reduce((acc, p) => {\n        if (p.providerId) {\n          acc[p.providerId] = [p.uid];\n        }\n        return acc;\n      }, {} as Record<string, string[]>),\n      sign_in_provider: currentUser.providerData[0]?.providerId || 'custom',\n      tenant: currentUser.tenantId,\n    },\n  };\n\n  return {\n    uid: currentUser.uid,\n    token: token,\n  };\n}\n\n/**\n * Builds the complete, simulated request object for the error message.\n * It safely tries to get the current authenticated user.\n * @param context The context of the failed Firestore operation.\n * @returns A structured request object.\n */\nfunction buildRequestObject(context: SecurityRuleContext): SecurityRuleRequest {\n  let authObject: FirebaseAuthObject | null = null;\n  try {\n    // Safely attempt to get the current user.\n    const firebaseAuth = getAuth();\n    const currentUser = firebaseAuth.currentUser;\n    if (currentUser) {\n      authObject = buildAuthObject(currentUser);\n    }\n  } catch {\n    // This will catch errors if the Firebase app is not yet initialized.\n    // In this case, we'll proceed without auth information.\n  }\n\n  return {\n    auth: authObject,\n    method: context.operation,\n    path: `/databases/(default)/documents/${context.path}`,\n    resource: context.requestResourceData ? { data: context.requestResourceData } : undefined,\n  };\n}\n\n/**\n * Builds the final, formatted error message for the LLM.\n * @param requestObject The simulated request object.\n * @returns A string containing the error message and the JSON payload.\n */\nfunction buildErrorMessage(requestObject: SecurityRuleRequest): string {\n  return `Missing or insufficient permissions: The following request was denied by Firestore Security Rules:\n${JSON.stringify(requestObject, null, 2)}`;\n}\n\n/**\n * A custom error class designed to be consumed by an LLM for debugging.\n * It structures the error information to mimic the request object\n * available in Firestore Security Rules.\n */\nexport class FirestorePermissionError extends Error {\n  public readonly request: SecurityRuleRequest;\n\n  constructor(context: SecurityRuleContext) {\n    const requestObject = buildRequestObject(context);\n    super(buildErrorMessage(requestObject));\n    this.name = 'FirebaseError';\n    this.request = requestObject;\n  }\n}\n"],"names":[],"mappings":";;;;;AACA;AAAA;AADA;;;AAoCA;;;;CAIC,GACD,SAAS,gBAAgB,WAAwB;QAkBzB;IAjBtB,IAAI,CAAC,aAAa;QAChB,OAAO;IACT;IAEA,MAAM,QAA2B;QAC/B,MAAM,YAAY,WAAW;QAC7B,OAAO,YAAY,KAAK;QACxB,gBAAgB,YAAY,aAAa;QACzC,cAAc,YAAY,WAAW;QACrC,KAAK,YAAY,GAAG;QACpB,UAAU;YACR,YAAY,YAAY,YAAY,CAAC,MAAM,CAAC,CAAC,KAAK;gBAChD,IAAI,EAAE,UAAU,EAAE;oBAChB,GAAG,CAAC,EAAE,UAAU,CAAC,GAAG;wBAAC,EAAE,GAAG;qBAAC;gBAC7B;gBACA,OAAO;YACT,GAAG,CAAC;YACJ,kBAAkB,EAAA,6BAAA,YAAY,YAAY,CAAC,EAAE,cAA3B,iDAAA,2BAA6B,UAAU,KAAI;YAC7D,QAAQ,YAAY,QAAQ;QAC9B;IACF;IAEA,OAAO;QACL,KAAK,YAAY,GAAG;QACpB,OAAO;IACT;AACF;AAEA;;;;;CAKC,GACD,SAAS,mBAAmB,OAA4B;IACtD,IAAI,aAAwC;IAC5C,IAAI;QACF,0CAA0C;QAC1C,MAAM,eAAe,IAAA,4KAAO;QAC5B,MAAM,cAAc,aAAa,WAAW;QAC5C,IAAI,aAAa;YACf,aAAa,gBAAgB;QAC/B;IACF,EAAE,UAAM;IACN,qEAAqE;IACrE,wDAAwD;IAC1D;IAEA,OAAO;QACL,MAAM;QACN,QAAQ,QAAQ,SAAS;QACzB,MAAM,AAAC,kCAA8C,OAAb,QAAQ,IAAI;QACpD,UAAU,QAAQ,mBAAmB,GAAG;YAAE,MAAM,QAAQ,mBAAmB;QAAC,IAAI;IAClF;AACF;AAEA;;;;CAIC,GACD,SAAS,kBAAkB,aAAkC;IAC3D,OAAO,AAAC,uGAC+B,OAAvC,KAAK,SAAS,CAAC,eAAe,MAAM;AACtC;AAOO,MAAM,iCAAiC;IAG5C,YAAY,OAA4B,CAAE;QACxC,MAAM,gBAAgB,mBAAmB;QACzC,KAAK,CAAC,kBAAkB,iBAJ1B,+KAAgB,WAAhB,KAAA;QAKE,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,OAAO,GAAG;IACjB;AACF","debugId":null}},
    {"offset": {"line": 1080, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/firestore/use-collection.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport {\n  query,\n  collection,\n  onSnapshot,\n  DocumentData,\n  FirestoreError,\n  QuerySnapshot,\n  QueryConstraint,\n} from 'firebase/firestore';\nimport { useFirestore } from '@/firebase/provider';\nimport { errorEmitter } from '@/firebase/error-emitter';\nimport { FirestorePermissionError } from '@/firebase/errors';\n\nexport type WithId<T> = T & { id: string };\n\nexport interface UseCollectionResult<T> {\n  data: WithId<T>[] | null;\n  isLoading: boolean;\n  error: FirestoreError | Error | null;\n}\n\nexport function useCollection<T = any>(\n  collectionName: string | null | undefined,\n  constraints: QueryConstraint[] | null | undefined\n): UseCollectionResult<T> {\n  const [data, setData] = useState<WithId<T>[] | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<FirestoreError | Error | null>(null);\n  const db = useFirestore();\n\n  const constraintsJSON = JSON.stringify(constraints);\n\n  useEffect(() => {\n    if (!db) {\n      setIsLoading(false);\n      return;\n    }\n\n    // Validación para asegurar que collectionName es un string válido\n    if (typeof collectionName !== 'string') {\n      if (collectionName !== null && collectionName !== undefined) {\n        console.warn(\"useCollection: collectionName no es un string válido\", collectionName);\n      }\n      setData(null);\n      setIsLoading(false);\n      return;\n    }\n\n    setIsLoading(true);\n\n    try {\n      const colRef = collection(db, collectionName);\n      const safeConstraints = constraints || [];\n      const q = query(colRef, ...safeConstraints);\n\n      const unsubscribe = onSnapshot(\n        q,\n        (snapshot: QuerySnapshot<DocumentData>) => {\n          const results: WithId<T>[] = [];\n          snapshot.forEach((doc) => {\n            results.push({ ...(doc.data() as T), id: doc.id });\n          });\n          setData(results);\n          setError(null);\n          setIsLoading(false);\n        },\n        (err: FirestoreError) => {\n          console.error(`Firestore error on collection '${collectionName}':`, err);\n          const contextualError = new FirestorePermissionError({\n            operation: 'list',\n            path: collectionName,\n          });\n          setError(contextualError);\n          setData(null);\n          setIsLoading(false);\n          errorEmitter.emit('permission-error', contextualError);\n        }\n      );\n\n      return () => unsubscribe();\n    } catch (e: any) {\n        console.error(\"Error setting up collection listener:\", e);\n        setError(e);\n        setIsLoading(false);\n    }\n\n  }, [collectionName, constraintsJSON, db]);\n\n  return { data, isLoading, error };\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AASA;AACA;AACA;;AAdA;;;;;;AAwBO,SAAS,cACd,cAAyC,EACzC,WAAiD;;IAEjD,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAqB;IACrD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAU;IACpD,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAgC;IAClE,MAAM,KAAK,IAAA,+IAAY;IAEvB,MAAM,kBAAkB,KAAK,SAAS,CAAC;IAEvC,IAAA,0KAAS;mCAAC;YACR,IAAI,CAAC,IAAI;gBACP,aAAa;gBACb;YACF;YAEA,kEAAkE;YAClE,IAAI,OAAO,mBAAmB,UAAU;gBACtC,IAAI,mBAAmB,QAAQ,mBAAmB,WAAW;oBAC3D,QAAQ,IAAI,CAAC,wDAAwD;gBACvE;gBACA,QAAQ;gBACR,aAAa;gBACb;YACF;YAEA,aAAa;YAEb,IAAI;gBACF,MAAM,SAAS,IAAA,oLAAU,EAAC,IAAI;gBAC9B,MAAM,kBAAkB,eAAe,EAAE;gBACzC,MAAM,IAAI,IAAA,+KAAK,EAAC,WAAW;gBAE3B,MAAM,cAAc,IAAA,oLAAU,EAC5B;2DACA,CAAC;wBACC,MAAM,UAAuB,EAAE;wBAC/B,SAAS,OAAO;mEAAC,CAAC;gCAChB,QAAQ,IAAI,CAAC;oCAAE,GAAI,IAAI,IAAI,EAAE;oCAAQ,IAAI,IAAI,EAAE;gCAAC;4BAClD;;wBACA,QAAQ;wBACR,SAAS;wBACT,aAAa;oBACf;;2DACA,CAAC;wBACC,QAAQ,KAAK,CAAC,AAAC,kCAAgD,OAAf,gBAAe,OAAK;wBACpE,MAAM,kBAAkB,IAAI,wJAAwB,CAAC;4BACnD,WAAW;4BACX,MAAM;wBACR;wBACA,SAAS;wBACT,QAAQ;wBACR,aAAa;wBACb,sJAAY,CAAC,IAAI,CAAC,oBAAoB;oBACxC;;gBAGF;+CAAO,IAAM;;YACf,EAAE,OAAO,GAAQ;gBACb,QAAQ,KAAK,CAAC,yCAAyC;gBACvD,SAAS;gBACT,aAAa;YACjB;QAEF;kCAAG;QAAC;QAAgB;QAAiB;KAAG;IAExC,OAAO;QAAE;QAAM;QAAW;IAAM;AAClC;GApEgB;;QAOH,+IAAY","debugId":null}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/firestore/use-doc.tsx"],"sourcesContent":["'use client';\n    \nimport { useState, useEffect } from 'react';\nimport {\n  DocumentReference,\n  onSnapshot,\n  DocumentData,\n  FirestoreError,\n  DocumentSnapshot,\n} from 'firebase/firestore';\nimport { errorEmitter } from '@/firebase/error-emitter';\nimport { FirestorePermissionError } from '@/firebase/errors';\n\n/** Utility type to add an 'id' field to a given type T. */\ntype WithId<T> = T & { id: string };\n\n/**\n * Interface for the return value of the useDoc hook.\n * @template T Type of the document data.\n */\nexport interface UseDocResult<T> {\n  data: WithId<T> | null; // Document data with ID, or null.\n  isLoading: boolean;       // True if loading.\n  error: FirestoreError | Error | null; // Error object, or null.\n}\n\n/**\n * React hook to subscribe to a single Firestore document in real-time.\n * Handles nullable references.\n * \n * IMPORTANT! YOU MUST MEMOIZE the inputted memoizedTargetRefOrQuery or BAD THINGS WILL HAPPEN\n * use useMemo to memoize it per React guidence.  Also make sure that it's dependencies are stable\n * references\n *\n *\n * @template T Optional type for document data. Defaults to any.\n * @param {DocumentReference<DocumentData> | null | undefined} docRef -\n * The Firestore DocumentReference. Waits if null/undefined.\n * @returns {UseDocResult<T>} Object with data, isLoading, error.\n */\nexport function useDoc<T = any>(\n  memoizedDocRef: DocumentReference<DocumentData> | null | undefined,\n): UseDocResult<T> {\n  type StateDataType = WithId<T> | null;\n\n  const [data, setData] = useState<StateDataType>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<FirestoreError | Error | null>(null);\n\n  useEffect(() => {\n    if (!memoizedDocRef) {\n      setData(null);\n      setIsLoading(false);\n      setError(null);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    // Optional: setData(null); // Clear previous data instantly\n\n    const unsubscribe = onSnapshot(\n      memoizedDocRef,\n      (snapshot: DocumentSnapshot<DocumentData>) => {\n        if (snapshot.exists()) {\n          setData({ ...(snapshot.data() as T), id: snapshot.id });\n        } else {\n          // Document does not exist\n          setData(null);\n        }\n        setError(null); // Clear any previous error on successful snapshot (even if doc doesn't exist)\n        setIsLoading(false);\n      },\n      (error: FirestoreError) => {\n        const contextualError = new FirestorePermissionError({\n          operation: 'get',\n          path: memoizedDocRef.path,\n        })\n\n        setError(contextualError)\n        setData(null)\n        setIsLoading(false)\n\n        // trigger global error propagation\n        errorEmitter.emit('permission-error', contextualError);\n      }\n    );\n\n    return () => unsubscribe();\n  }, [memoizedDocRef]); // Re-run if the memoizedDocRef changes.\n\n  return { data, isLoading, error };\n}"],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AAOA;AACA;;AAXA;;;;;AAwCO,SAAS,OACd,cAAkE;;IAIlE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAgB;IAChD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAU;IACpD,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAgC;IAElE,IAAA,0KAAS;4BAAC;YACR,IAAI,CAAC,gBAAgB;gBACnB,QAAQ;gBACR,aAAa;gBACb,SAAS;gBACT;YACF;YAEA,aAAa;YACb,SAAS;YACT,4DAA4D;YAE5D,MAAM,cAAc,IAAA,oLAAU,EAC5B;gDACA,CAAC;oBACC,IAAI,SAAS,MAAM,IAAI;wBACrB,QAAQ;4BAAE,GAAI,SAAS,IAAI,EAAE;4BAAQ,IAAI,SAAS,EAAE;wBAAC;oBACvD,OAAO;wBACL,0BAA0B;wBAC1B,QAAQ;oBACV;oBACA,SAAS,OAAO,8EAA8E;oBAC9F,aAAa;gBACf;;gDACA,CAAC;oBACC,MAAM,kBAAkB,IAAI,wJAAwB,CAAC;wBACnD,WAAW;wBACX,MAAM,eAAe,IAAI;oBAC3B;oBAEA,SAAS;oBACT,QAAQ;oBACR,aAAa;oBAEb,mCAAmC;oBACnC,sJAAY,CAAC,IAAI,CAAC,oBAAoB;gBACxC;;YAGF;oCAAO,IAAM;;QACf;2BAAG;QAAC;KAAe,GAAG,wCAAwC;IAE9D,OAAO;QAAE;QAAM;QAAW;IAAM;AAClC;GApDgB","debugId":null}},
    {"offset": {"line": 1263, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/non-blocking-updates.tsx"],"sourcesContent":["'use client';\n    \nimport {\n  setDoc,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  CollectionReference,\n  DocumentReference,\n  SetOptions,\n} from 'firebase/firestore';\nimport { errorEmitter } from '@/firebase/error-emitter';\nimport {FirestorePermissionError} from '@/firebase/errors';\n\n/**\n * Initiates a setDoc operation for a document reference.\n * Does NOT await the write operation internally.\n */\nexport function setDocumentNonBlocking(docRef: DocumentReference, data: any, options: SetOptions) {\n  setDoc(docRef, data, options).catch(error => {\n    errorEmitter.emit(\n      'permission-error',\n      new FirestorePermissionError({\n        path: docRef.path,\n        operation: 'write', // or 'create'/'update' based on options\n        requestResourceData: data,\n      })\n    )\n  })\n  // Execution continues immediately\n}\n\n\n/**\n * Initiates an addDoc operation for a collection reference.\n * Does NOT await the write operation internally.\n * Returns the Promise for the new doc ref, but typically not awaited by caller.\n */\nexport function addDocumentNonBlocking(colRef: CollectionReference, data: any) {\n  const promise = addDoc(colRef, data)\n    .catch(error => {\n      errorEmitter.emit(\n        'permission-error',\n        new FirestorePermissionError({\n          path: colRef.path,\n          operation: 'create',\n          requestResourceData: data,\n        })\n      )\n    });\n  return promise;\n}\n\n\n/**\n * Initiates an updateDoc operation for a document reference.\n * Does NOT await the write operation internally.\n */\nexport function updateDocumentNonBlocking(docRef: DocumentReference, data: any) {\n  updateDoc(docRef, data)\n    .catch(error => {\n      errorEmitter.emit(\n        'permission-error',\n        new FirestorePermissionError({\n          path: docRef.path,\n          operation: 'update',\n          requestResourceData: data,\n        })\n      )\n    });\n}\n\n\n/**\n * Initiates a deleteDoc operation for a document reference.\n * Does NOT await the write operation internally.\n */\nexport function deleteDocumentNonBlocking(docRef: DocumentReference) {\n  deleteDoc(docRef)\n    .catch(error => {\n      errorEmitter.emit(\n        'permission-error',\n        new FirestorePermissionError({\n          path: docRef.path,\n          operation: 'delete',\n        })\n      )\n    });\n}"],"names":[],"mappings":";;;;;;;;;;AAEA;AAAA;AASA;AACA;AAZA;;;;AAkBO,SAAS,uBAAuB,MAAyB,EAAE,IAAS,EAAE,OAAmB;IAC9F,IAAA,gLAAM,EAAC,QAAQ,MAAM,SAAS,KAAK,CAAC,CAAA;QAClC,sJAAY,CAAC,IAAI,CACf,oBACA,IAAI,wJAAwB,CAAC;YAC3B,MAAM,OAAO,IAAI;YACjB,WAAW;YACX,qBAAqB;QACvB;IAEJ;AACA,kCAAkC;AACpC;AAQO,SAAS,uBAAuB,MAA2B,EAAE,IAAS;IAC3E,MAAM,UAAU,IAAA,gLAAM,EAAC,QAAQ,MAC5B,KAAK,CAAC,CAAA;QACL,sJAAY,CAAC,IAAI,CACf,oBACA,IAAI,wJAAwB,CAAC;YAC3B,MAAM,OAAO,IAAI;YACjB,WAAW;YACX,qBAAqB;QACvB;IAEJ;IACF,OAAO;AACT;AAOO,SAAS,0BAA0B,MAAyB,EAAE,IAAS;IAC5E,IAAA,mLAAS,EAAC,QAAQ,MACf,KAAK,CAAC,CAAA;QACL,sJAAY,CAAC,IAAI,CACf,oBACA,IAAI,wJAAwB,CAAC;YAC3B,MAAM,OAAO,IAAI;YACjB,WAAW;YACX,qBAAqB;QACvB;IAEJ;AACJ;AAOO,SAAS,0BAA0B,MAAyB;IACjE,IAAA,mLAAS,EAAC,QACP,KAAK,CAAC,CAAA;QACL,sJAAY,CAAC,IAAI,CACf,oBACA,IAAI,wJAAwB,CAAC;YAC3B,MAAM,OAAO,IAAI;YACjB,WAAW;QACb;IAEJ;AACJ","debugId":null}},
    {"offset": {"line": 1325, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/non-blocking-login.tsx"],"sourcesContent":["'use client';\nimport {\n  Auth, // Import Auth type for type hinting\n  signInAnonymously,\n  createUserWithEmailAndPassword,\n  signInWithEmailAndPassword,\n  // Assume getAuth and app are initialized elsewhere\n} from 'firebase/auth';\n\n/** Initiate anonymous sign-in (non-blocking). */\nexport function initiateAnonymousSignIn(authInstance: Auth): void {\n  // CRITICAL: Call signInAnonymously directly. Do NOT use 'await signInAnonymously(...)'.\n  signInAnonymously(authInstance);\n  // Code continues immediately. Auth state change is handled by onAuthStateChanged listener.\n}\n\n/** Initiate email/password sign-up (non-blocking). */\nexport function initiateEmailSignUp(authInstance: Auth, email: string, password: string): void {\n  // CRITICAL: Call createUserWithEmailAndPassword directly. Do NOT use 'await createUserWithEmailAndPassword(...)'.\n  createUserWithEmailAndPassword(authInstance, email, password);\n  // Code continues immediately. Auth state change is handled by onAuthStateChanged listener.\n}\n\n/** Initiate email/password sign-in (non-blocking). */\nexport function initiateEmailSignIn(authInstance: Auth, email: string, password: string): void {\n  // CRITICAL: Call signInWithEmailAndPassword directly. Do NOT use 'await signInWithEmailAndPassword(...)'.\n  signInWithEmailAndPassword(authInstance, email, password);\n  // Code continues immediately. Auth state change is handled by onAuthStateChanged listener.\n}\n"],"names":[],"mappings":";;;;;;;;AACA;AAAA;AADA;;AAUO,SAAS,wBAAwB,YAAkB;IACxD,wFAAwF;IACxF,IAAA,sLAAiB,EAAC;AAClB,2FAA2F;AAC7F;AAGO,SAAS,oBAAoB,YAAkB,EAAE,KAAa,EAAE,QAAgB;IACrF,kHAAkH;IAClH,IAAA,mMAA8B,EAAC,cAAc,OAAO;AACpD,2FAA2F;AAC7F;AAGO,SAAS,oBAAoB,YAAkB,EAAE,KAAa,EAAE,QAAgB;IACrF,0GAA0G;IAC1G,IAAA,+LAA0B,EAAC,cAAc,OAAO;AAChD,2FAA2F;AAC7F","debugId":null}},
    {"offset": {"line": 1359, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/hooks/useUserProfile.ts"],"sourcesContent":["'use client';\nimport { useUser, useDoc, useFirestore, useMemoFirebase } from '@/firebase';\nimport { doc } from 'firebase/firestore';\n\n// Define the shape of the user profile document from Firestore\ninterface UserProfile {\n  id: string;\n  email: string;\n  createdAt: string;\n  role: 'free' | 'pro';\n  photoURL?: string;\n}\n\nexport function useUserProfile() {\n  const { user, isUserLoading: isAuthLoading, userError: authError } = useUser();\n  const firestore = useFirestore();\n\n  const userDocRef = useMemoFirebase(\n    () => (user ? doc(firestore, 'users', user.uid) : null),\n    [firestore, user]\n  );\n\n  const { data: profile, isLoading: isProfileLoading, error: profileError } = useDoc<UserProfile>(userDocRef);\n\n  return {\n    user, // The Firebase Auth user object\n    profile, // The user profile data from Firestore\n    isLoading: isAuthLoading || isProfileLoading,\n    error: authError || profileError,\n    isPro: profile?.role === 'pro',\n  };\n}\n"],"names":[],"mappings":";;;;AACA;AAAA;AAAA;AACA;AAAA;;AAFA;;;AAaO,SAAS;;IACd,MAAM,EAAE,IAAI,EAAE,eAAe,aAAa,EAAE,WAAW,SAAS,EAAE,GAAG,IAAA,0IAAO;IAC5E,MAAM,YAAY,IAAA,+IAAY;IAE9B,MAAM,aAAa,IAAA,kJAAe;sDAChC,IAAO,OAAO,IAAA,6KAAG,EAAC,WAAW,SAAS,KAAK,GAAG,IAAI;qDAClD;QAAC;QAAW;KAAK;IAGnB,MAAM,EAAE,MAAM,OAAO,EAAE,WAAW,gBAAgB,EAAE,OAAO,YAAY,EAAE,GAAG,IAAA,wJAAM,EAAc;IAEhG,OAAO;QACL;QACA;QACA,WAAW,iBAAiB;QAC5B,OAAO,aAAa;QACpB,OAAO,CAAA,oBAAA,8BAAA,QAAS,IAAI,MAAK;IAC3B;AACF;GAlBgB;;QACuD,0IAAO;QAC1D,+IAAY;QAEX,kJAAe;QAK0C,wJAAM","debugId":null}},
    {"offset": {"line": 1406, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/firebase/index.ts"],"sourcesContent":["'use client';\n\nimport { firebaseConfig } from '@/firebase/config';\nimport { initializeApp, getApps, getApp, FirebaseApp } from 'firebase/app';\nimport { Auth, getAuth } from 'firebase/auth';\nimport { Firestore, getFirestore } from 'firebase/firestore';\nimport { getStorage, type Storage } from 'firebase/storage';\n\n// IMPORTANT: DO NOT MODIFY THIS FUNCTION\nexport function initializeFirebase() {\n  if (getApps().length) {\n    return getSdks(getApp());\n  }\n\n  // Important! initializeApp() is called without any arguments because Firebase App Hosting\n  // integrates with the initializeApp() function to provide the environment variables needed to\n  // populate the FirebaseOptions in production. It is critical that we attempt to call initializeApp()\n  // without arguments.\n  let firebaseApp;\n  try {\n    // Attempt to initialize via Firebase App Hosting environment variables\n    firebaseApp = initializeApp();\n  } catch (e) {\n    // Only warn in production because it's normal to use the firebaseConfig to initialize\n    // during development\n    if (process.env.NODE_ENV === \"production\") {\n      console.warn('Automatic initialization failed. Falling back to firebase config object.', e);\n    }\n    \n    // Fallback for local development or other environments\n    if (!firebaseConfig.apiKey) {\n      throw new Error(\"Firebase API key is missing. Please provide it in your .env file as NEXT_PUBLIC_FIREBASE_API_KEY.\");\n    }\n    firebaseApp = initializeApp(firebaseConfig);\n  }\n\n  return getSdks(firebaseApp);\n}\n\nlet auth: Auth | null = null;\nlet firestore: Firestore | null = null;\nlet storage: Storage | null = null;\n\nexport function getSdks(firebaseApp: FirebaseApp) {\n  if (!auth) {\n    auth = getAuth(firebaseApp);\n  }\n\n  if (!firestore) {\n    firestore = getFirestore(firebaseApp);\n  }\n\n  if (!storage) {\n    storage = getStorage(firebaseApp);\n  }\n\n  return {\n    firebaseApp,\n    auth,\n    firestore,\n    storage,\n  };\n}\n\n\nexport * from './provider';\nexport * from './client-provider';\nexport * from './firestore/use-collection';\nexport * from './firestore/use-doc';\nexport * from './non-blocking-updates';\nexport * from './non-blocking-login';\nexport * from './errors';\nexport * from './error-emitter';\nexport * from '../hooks/useUserProfile';\n"],"names":[],"mappings":";;;;;;AAyBQ;AAvBR;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AA2DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;;;;;;AASO,SAAS;IACd,IAAI,IAAA,kLAAO,IAAG,MAAM,EAAE;QACpB,OAAO,QAAQ,IAAA,iLAAM;IACvB;IAEA,0FAA0F;IAC1F,8FAA8F;IAC9F,qGAAqG;IACrG,qBAAqB;IACrB,IAAI;IACJ,IAAI;QACF,uEAAuE;QACvE,cAAc,IAAA,wLAAa;IAC7B,EAAE,OAAO,GAAG;QACV,sFAAsF;QACtF,qBAAqB;QACrB;;QAIA,uDAAuD;QACvD,IAAI,CAAC,8IAAc,CAAC,MAAM,EAAE;YAC1B,MAAM,IAAI,MAAM;QAClB;QACA,cAAc,IAAA,wLAAa,EAAC,8IAAc;IAC5C;IAEA,OAAO,QAAQ;AACjB;AAEA,IAAI,OAAoB;AACxB,IAAI,YAA8B;AAClC,IAAI,UAA0B;AAEvB,SAAS,QAAQ,WAAwB;IAC9C,IAAI,CAAC,MAAM;QACT,OAAO,IAAA,4KAAO,EAAC;IACjB;IAEA,IAAI,CAAC,WAAW;QACd,YAAY,IAAA,sLAAY,EAAC;IAC3B;IAEA,IAAI,CAAC,SAAS;QACZ,UAAU,IAAA,kLAAU,EAAC;IACvB;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 1562, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/components/providers/theme-provider.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\n\ntype Theme = 'light' | 'dark' | 'cosmos';\n\ninterface ThemeContextType {\n  theme: Theme;\n  setTheme: (theme: Theme) => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nexport function ThemeProvider({ children }: { children: ReactNode }) {\n  const [theme, setThemeState] = useState<Theme>('light'); // Default to light\n\n  useEffect(() => {\n    // On initial load, try to get the theme from localStorage\n    const storedTheme = localStorage.getItem('theme') as Theme | null;\n    if (storedTheme && ['light', 'dark', 'cosmos'].includes(storedTheme)) {\n      setThemeState(storedTheme);\n    }\n  }, []);\n\n  useEffect(() => {\n    // Whenever the theme changes, update the class on the html element\n    const root = window.document.documentElement;\n    root.classList.remove('light', 'dark', 'cosmos');\n    root.classList.add(theme);\n\n    // Also save the theme to localStorage\n    localStorage.setItem('theme', theme);\n  }, [theme]);\n\n  const setTheme = (newTheme: Theme) => {\n    setThemeState(newTheme);\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;;;AAFA;;AAWA,MAAM,6BAAe,IAAA,8KAAa,EAA+B;AAE1D,SAAS,cAAc,KAAqC;QAArC,EAAE,QAAQ,EAA2B,GAArC;;IAC5B,MAAM,CAAC,OAAO,cAAc,GAAG,IAAA,yKAAQ,EAAQ,UAAU,mBAAmB;IAE5E,IAAA,0KAAS;mCAAC;YACR,0DAA0D;YAC1D,MAAM,cAAc,aAAa,OAAO,CAAC;YACzC,IAAI,eAAe;gBAAC;gBAAS;gBAAQ;aAAS,CAAC,QAAQ,CAAC,cAAc;gBACpE,cAAc;YAChB;QACF;kCAAG,EAAE;IAEL,IAAA,0KAAS;mCAAC;YACR,mEAAmE;YACnE,MAAM,OAAO,OAAO,QAAQ,CAAC,eAAe;YAC5C,KAAK,SAAS,CAAC,MAAM,CAAC,SAAS,QAAQ;YACvC,KAAK,SAAS,CAAC,GAAG,CAAC;YAEnB,sCAAsC;YACtC,aAAa,OAAO,CAAC,SAAS;QAChC;kCAAG;QAAC;KAAM;IAEV,MAAM,WAAW,CAAC;QAChB,cAAc;IAChB;IAEA,qBACE,6LAAC,aAAa,QAAQ;QAAC,OAAO;YAAE;YAAO;QAAS;kBAC7C;;;;;;AAGP;GA9BgB;KAAA;AAgCT,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB","debugId":null}},
    {"offset": {"line": 1645, "column": 0}, "map": {"version":3,"sources":["file:///home/user/CERO/src/components/providers/language-provider.tsx"],"sourcesContent":["'use client';\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport es from '@/lib/locales/es.json';\nimport en from '@/lib/locales/en.json';\n\ntype Locale = 'es' | 'en';\ntype Translations = typeof es;\n\nconst translations: Record<Locale, Translations> = { es, en };\n\ninterface LanguageContextType {\n  locale: Locale;\n  setLocale: (locale: Locale) => void;\n  t: (key: keyof Translations, params?: { [key: string]: string | number }) => string;\n}\n\nconst LanguageContext = createContext<LanguageContextType | undefined>(undefined);\n\nexport function LanguageProvider({ children }: { children: ReactNode }) {\n  const [locale, setLocaleState] = useState<Locale>('es');\n\n  useEffect(() => {\n    const storedLocale = localStorage.getItem('locale') as Locale | null;\n    if (storedLocale && ['es', 'en'].includes(storedLocale)) {\n      setLocaleState(storedLocale);\n    } else {\n        // First time visit, check browser language\n        const browserLang = navigator.language.split('-')[0];\n        if (browserLang === 'en') {\n            setLocaleState('en');\n        }\n    }\n  }, []);\n\n  const setLocale = (newLocale: Locale) => {\n    setLocaleState(newLocale);\n    localStorage.setItem('locale', newLocale);\n  };\n\n  const t = useCallback((key: keyof Translations, params?: { [key: string]: string | number }): string => {\n    let translation = translations[locale]?.[key] || key;\n    if (params) {\n        Object.keys(params).forEach(paramKey => {\n            translation = translation.replace(`{${paramKey}}`, String(params[paramKey]));\n        });\n    }\n    return translation;\n  }, [locale]);\n\n  return (\n    <LanguageContext.Provider value={{ locale, setLocale, t }}>\n      {children}\n    </LanguageContext.Provider>\n  );\n}\n\nexport function useTranslation() {\n  const context = useContext(LanguageContext);\n  if (context === undefined) {\n    throw new Error('useTranslation must be used within a LanguageProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;AAJA;;;;AASA,MAAM,eAA6C;IAAE,IAAA,8GAAE;IAAE,IAAA,8GAAE;AAAC;AAQ5D,MAAM,gCAAkB,IAAA,8KAAa,EAAkC;AAEhE,SAAS,iBAAiB,KAAqC;QAArC,EAAE,QAAQ,EAA2B,GAArC;;IAC/B,MAAM,CAAC,QAAQ,eAAe,GAAG,IAAA,yKAAQ,EAAS;IAElD,IAAA,0KAAS;sCAAC;YACR,MAAM,eAAe,aAAa,OAAO,CAAC;YAC1C,IAAI,gBAAgB;gBAAC;gBAAM;aAAK,CAAC,QAAQ,CAAC,eAAe;gBACvD,eAAe;YACjB,OAAO;gBACH,2CAA2C;gBAC3C,MAAM,cAAc,UAAU,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACpD,IAAI,gBAAgB,MAAM;oBACtB,eAAe;gBACnB;YACJ;QACF;qCAAG,EAAE;IAEL,MAAM,YAAY,CAAC;QACjB,eAAe;QACf,aAAa,OAAO,CAAC,UAAU;IACjC;IAEA,MAAM,IAAI,IAAA,4KAAW;2CAAC,CAAC,KAAyB;gBAC5B;YAAlB,IAAI,cAAc,EAAA,uBAAA,YAAY,CAAC,OAAO,cAApB,2CAAA,oBAAsB,CAAC,IAAI,KAAI;YACjD,IAAI,QAAQ;gBACR,OAAO,IAAI,CAAC,QAAQ,OAAO;uDAAC,CAAA;wBACxB,cAAc,YAAY,OAAO,CAAC,AAAC,IAAY,OAAT,UAAS,MAAI,OAAO,MAAM,CAAC,SAAS;oBAC9E;;YACJ;YACA,OAAO;QACT;0CAAG;QAAC;KAAO;IAEX,qBACE,6LAAC,gBAAgB,QAAQ;QAAC,OAAO;YAAE;YAAQ;YAAW;QAAE;kBACrD;;;;;;AAGP;GApCgB;KAAA;AAsCT,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB","debugId":null}}]
}